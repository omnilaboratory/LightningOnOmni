// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.6.1
// source: info-tracker.proto

package tkrpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// InfoTrackerClient is the client API for InfoTracker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InfoTrackerClient interface {
	//every HeartBeat will set nodeInfo.isonline=true; every HeartBeat disconnect will set  nodeInfo.isonline=false;
	HeartBeat(ctx context.Context, opts ...grpc.CallOption) (InfoTracker_HeartBeatClient, error)
	//map to old func Logout Login
	UpdateNodeInfo(ctx context.Context, in *UpdateNodeInfoReq, opts ...grpc.CallOption) (*EmptyRes, error)
	//map to old func userLogout userLogin
	UpdateUserInfo(ctx context.Context, in *UpdateUserInfoReq, opts ...grpc.CallOption) (*EmptyRes, error)
	//map to old func updateUsers
	UpdateUserInfos(ctx context.Context, in *UpdateUserInfosReq, opts ...grpc.CallOption) (*EmptyRes, error)
	//map to old func: GetUserState , GetUserP2pNodeId
	//Request:SetUserInfoReq{user_id,node_Id}
	//old GetUserP2pNodeId use request:SetUserInfoReq{user_id} ;  may not work when user login on multi node
	GetUserInfo(ctx context.Context, in *UpdateUserInfoReq, opts ...grpc.CallOption) (*UserInfo, error)
	//Map to old function GetAllUsers
	GetUserInfos(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*UserInfosRes, error)
	//map old function GetAllObdNodes
	GetNodes(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*NodeInfosRes, error)
	UpdateChannelInfo(ctx context.Context, in *ChannelInfo, opts ...grpc.CallOption) (*ChannelInfo, error)
	UpdateChannelInfos(ctx context.Context, in *UpdateChannelInfosReq, opts ...grpc.CallOption) (*EmptyRes, error)
	//map to old ChannelService.GetChannelState
	GetChannelInfo(ctx context.Context, in *SimpleFilter, opts ...grpc.CallOption) (*ChannelInfo, error)
	GetChannels(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*NodeInfosRes, error)
	// map old function updateHtlcInfo
	UpdateHtlcInfo(ctx context.Context, in *HtlcInfo, opts ...grpc.CallOption) (*HtlcInfo, error)
	//map old function getPath
	HtlcGetPath(ctx context.Context, in *HtlcGetPathReq, opts ...grpc.CallOption) (*HtlcGetPathRes, error)
	//map old function GetHtlcCurrState
	GetHtlcInfo(ctx context.Context, in *GetHtlcInfoReq, opts ...grpc.CallOption) (*HtlcInfo, error)
}

type infoTrackerClient struct {
	cc grpc.ClientConnInterface
}

func NewInfoTrackerClient(cc grpc.ClientConnInterface) InfoTrackerClient {
	return &infoTrackerClient{cc}
}

func (c *infoTrackerClient) HeartBeat(ctx context.Context, opts ...grpc.CallOption) (InfoTracker_HeartBeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &InfoTracker_ServiceDesc.Streams[0], "/tkrpc.InfoTracker/HeartBeat", opts...)
	if err != nil {
		return nil, err
	}
	x := &infoTrackerHeartBeatClient{stream}
	return x, nil
}

type InfoTracker_HeartBeatClient interface {
	Send(*UpdateNodeInfoReq) error
	CloseAndRecv() (*EmptyRes, error)
	grpc.ClientStream
}

type infoTrackerHeartBeatClient struct {
	grpc.ClientStream
}

func (x *infoTrackerHeartBeatClient) Send(m *UpdateNodeInfoReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *infoTrackerHeartBeatClient) CloseAndRecv() (*EmptyRes, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(EmptyRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *infoTrackerClient) UpdateNodeInfo(ctx context.Context, in *UpdateNodeInfoReq, opts ...grpc.CallOption) (*EmptyRes, error) {
	out := new(EmptyRes)
	err := c.cc.Invoke(ctx, "/tkrpc.InfoTracker/UpdateNodeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoTrackerClient) UpdateUserInfo(ctx context.Context, in *UpdateUserInfoReq, opts ...grpc.CallOption) (*EmptyRes, error) {
	out := new(EmptyRes)
	err := c.cc.Invoke(ctx, "/tkrpc.InfoTracker/UpdateUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoTrackerClient) UpdateUserInfos(ctx context.Context, in *UpdateUserInfosReq, opts ...grpc.CallOption) (*EmptyRes, error) {
	out := new(EmptyRes)
	err := c.cc.Invoke(ctx, "/tkrpc.InfoTracker/UpdateUserInfos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoTrackerClient) GetUserInfo(ctx context.Context, in *UpdateUserInfoReq, opts ...grpc.CallOption) (*UserInfo, error) {
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, "/tkrpc.InfoTracker/GetUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoTrackerClient) GetUserInfos(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*UserInfosRes, error) {
	out := new(UserInfosRes)
	err := c.cc.Invoke(ctx, "/tkrpc.InfoTracker/GetUserInfos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoTrackerClient) GetNodes(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*NodeInfosRes, error) {
	out := new(NodeInfosRes)
	err := c.cc.Invoke(ctx, "/tkrpc.InfoTracker/GetNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoTrackerClient) UpdateChannelInfo(ctx context.Context, in *ChannelInfo, opts ...grpc.CallOption) (*ChannelInfo, error) {
	out := new(ChannelInfo)
	err := c.cc.Invoke(ctx, "/tkrpc.InfoTracker/UpdateChannelInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoTrackerClient) UpdateChannelInfos(ctx context.Context, in *UpdateChannelInfosReq, opts ...grpc.CallOption) (*EmptyRes, error) {
	out := new(EmptyRes)
	err := c.cc.Invoke(ctx, "/tkrpc.InfoTracker/UpdateChannelInfos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoTrackerClient) GetChannelInfo(ctx context.Context, in *SimpleFilter, opts ...grpc.CallOption) (*ChannelInfo, error) {
	out := new(ChannelInfo)
	err := c.cc.Invoke(ctx, "/tkrpc.InfoTracker/GetChannelInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoTrackerClient) GetChannels(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*NodeInfosRes, error) {
	out := new(NodeInfosRes)
	err := c.cc.Invoke(ctx, "/tkrpc.InfoTracker/GetChannels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoTrackerClient) UpdateHtlcInfo(ctx context.Context, in *HtlcInfo, opts ...grpc.CallOption) (*HtlcInfo, error) {
	out := new(HtlcInfo)
	err := c.cc.Invoke(ctx, "/tkrpc.InfoTracker/UpdateHtlcInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoTrackerClient) HtlcGetPath(ctx context.Context, in *HtlcGetPathReq, opts ...grpc.CallOption) (*HtlcGetPathRes, error) {
	out := new(HtlcGetPathRes)
	err := c.cc.Invoke(ctx, "/tkrpc.InfoTracker/HtlcGetPath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoTrackerClient) GetHtlcInfo(ctx context.Context, in *GetHtlcInfoReq, opts ...grpc.CallOption) (*HtlcInfo, error) {
	out := new(HtlcInfo)
	err := c.cc.Invoke(ctx, "/tkrpc.InfoTracker/GetHtlcInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InfoTrackerServer is the server API for InfoTracker service.
// All implementations must embed UnimplementedInfoTrackerServer
// for forward compatibility
type InfoTrackerServer interface {
	//every HeartBeat will set nodeInfo.isonline=true; every HeartBeat disconnect will set  nodeInfo.isonline=false;
	HeartBeat(InfoTracker_HeartBeatServer) error
	//map to old func Logout Login
	UpdateNodeInfo(context.Context, *UpdateNodeInfoReq) (*EmptyRes, error)
	//map to old func userLogout userLogin
	UpdateUserInfo(context.Context, *UpdateUserInfoReq) (*EmptyRes, error)
	//map to old func updateUsers
	UpdateUserInfos(context.Context, *UpdateUserInfosReq) (*EmptyRes, error)
	//map to old func: GetUserState , GetUserP2pNodeId
	//Request:SetUserInfoReq{user_id,node_Id}
	//old GetUserP2pNodeId use request:SetUserInfoReq{user_id} ;  may not work when user login on multi node
	GetUserInfo(context.Context, *UpdateUserInfoReq) (*UserInfo, error)
	//Map to old function GetAllUsers
	GetUserInfos(context.Context, *ListReq) (*UserInfosRes, error)
	//map old function GetAllObdNodes
	GetNodes(context.Context, *ListReq) (*NodeInfosRes, error)
	UpdateChannelInfo(context.Context, *ChannelInfo) (*ChannelInfo, error)
	UpdateChannelInfos(context.Context, *UpdateChannelInfosReq) (*EmptyRes, error)
	//map to old ChannelService.GetChannelState
	GetChannelInfo(context.Context, *SimpleFilter) (*ChannelInfo, error)
	GetChannels(context.Context, *ListReq) (*NodeInfosRes, error)
	// map old function updateHtlcInfo
	UpdateHtlcInfo(context.Context, *HtlcInfo) (*HtlcInfo, error)
	//map old function getPath
	HtlcGetPath(context.Context, *HtlcGetPathReq) (*HtlcGetPathRes, error)
	//map old function GetHtlcCurrState
	GetHtlcInfo(context.Context, *GetHtlcInfoReq) (*HtlcInfo, error)
	mustEmbedUnimplementedInfoTrackerServer()
}

// UnimplementedInfoTrackerServer must be embedded to have forward compatible implementations.
type UnimplementedInfoTrackerServer struct {
}

func (UnimplementedInfoTrackerServer) HeartBeat(InfoTracker_HeartBeatServer) error {
	return status.Errorf(codes.Unimplemented, "method HeartBeat not implemented")
}
func (UnimplementedInfoTrackerServer) UpdateNodeInfo(context.Context, *UpdateNodeInfoReq) (*EmptyRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNodeInfo not implemented")
}
func (UnimplementedInfoTrackerServer) UpdateUserInfo(context.Context, *UpdateUserInfoReq) (*EmptyRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserInfo not implemented")
}
func (UnimplementedInfoTrackerServer) UpdateUserInfos(context.Context, *UpdateUserInfosReq) (*EmptyRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserInfos not implemented")
}
func (UnimplementedInfoTrackerServer) GetUserInfo(context.Context, *UpdateUserInfoReq) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfo not implemented")
}
func (UnimplementedInfoTrackerServer) GetUserInfos(context.Context, *ListReq) (*UserInfosRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfos not implemented")
}
func (UnimplementedInfoTrackerServer) GetNodes(context.Context, *ListReq) (*NodeInfosRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodes not implemented")
}
func (UnimplementedInfoTrackerServer) UpdateChannelInfo(context.Context, *ChannelInfo) (*ChannelInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateChannelInfo not implemented")
}
func (UnimplementedInfoTrackerServer) UpdateChannelInfos(context.Context, *UpdateChannelInfosReq) (*EmptyRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateChannelInfos not implemented")
}
func (UnimplementedInfoTrackerServer) GetChannelInfo(context.Context, *SimpleFilter) (*ChannelInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChannelInfo not implemented")
}
func (UnimplementedInfoTrackerServer) GetChannels(context.Context, *ListReq) (*NodeInfosRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChannels not implemented")
}
func (UnimplementedInfoTrackerServer) UpdateHtlcInfo(context.Context, *HtlcInfo) (*HtlcInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateHtlcInfo not implemented")
}
func (UnimplementedInfoTrackerServer) HtlcGetPath(context.Context, *HtlcGetPathReq) (*HtlcGetPathRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HtlcGetPath not implemented")
}
func (UnimplementedInfoTrackerServer) GetHtlcInfo(context.Context, *GetHtlcInfoReq) (*HtlcInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHtlcInfo not implemented")
}
func (UnimplementedInfoTrackerServer) mustEmbedUnimplementedInfoTrackerServer() {}

// UnsafeInfoTrackerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InfoTrackerServer will
// result in compilation errors.
type UnsafeInfoTrackerServer interface {
	mustEmbedUnimplementedInfoTrackerServer()
}

func RegisterInfoTrackerServer(s grpc.ServiceRegistrar, srv InfoTrackerServer) {
	s.RegisterService(&InfoTracker_ServiceDesc, srv)
}

func _InfoTracker_HeartBeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(InfoTrackerServer).HeartBeat(&infoTrackerHeartBeatServer{stream})
}

type InfoTracker_HeartBeatServer interface {
	SendAndClose(*EmptyRes) error
	Recv() (*UpdateNodeInfoReq, error)
	grpc.ServerStream
}

type infoTrackerHeartBeatServer struct {
	grpc.ServerStream
}

func (x *infoTrackerHeartBeatServer) SendAndClose(m *EmptyRes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *infoTrackerHeartBeatServer) Recv() (*UpdateNodeInfoReq, error) {
	m := new(UpdateNodeInfoReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _InfoTracker_UpdateNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNodeInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoTrackerServer).UpdateNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tkrpc.InfoTracker/UpdateNodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoTrackerServer).UpdateNodeInfo(ctx, req.(*UpdateNodeInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoTracker_UpdateUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoTrackerServer).UpdateUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tkrpc.InfoTracker/UpdateUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoTrackerServer).UpdateUserInfo(ctx, req.(*UpdateUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoTracker_UpdateUserInfos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserInfosReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoTrackerServer).UpdateUserInfos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tkrpc.InfoTracker/UpdateUserInfos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoTrackerServer).UpdateUserInfos(ctx, req.(*UpdateUserInfosReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoTracker_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoTrackerServer).GetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tkrpc.InfoTracker/GetUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoTrackerServer).GetUserInfo(ctx, req.(*UpdateUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoTracker_GetUserInfos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoTrackerServer).GetUserInfos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tkrpc.InfoTracker/GetUserInfos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoTrackerServer).GetUserInfos(ctx, req.(*ListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoTracker_GetNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoTrackerServer).GetNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tkrpc.InfoTracker/GetNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoTrackerServer).GetNodes(ctx, req.(*ListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoTracker_UpdateChannelInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoTrackerServer).UpdateChannelInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tkrpc.InfoTracker/UpdateChannelInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoTrackerServer).UpdateChannelInfo(ctx, req.(*ChannelInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoTracker_UpdateChannelInfos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateChannelInfosReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoTrackerServer).UpdateChannelInfos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tkrpc.InfoTracker/UpdateChannelInfos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoTrackerServer).UpdateChannelInfos(ctx, req.(*UpdateChannelInfosReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoTracker_GetChannelInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SimpleFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoTrackerServer).GetChannelInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tkrpc.InfoTracker/GetChannelInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoTrackerServer).GetChannelInfo(ctx, req.(*SimpleFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoTracker_GetChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoTrackerServer).GetChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tkrpc.InfoTracker/GetChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoTrackerServer).GetChannels(ctx, req.(*ListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoTracker_UpdateHtlcInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HtlcInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoTrackerServer).UpdateHtlcInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tkrpc.InfoTracker/UpdateHtlcInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoTrackerServer).UpdateHtlcInfo(ctx, req.(*HtlcInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoTracker_HtlcGetPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HtlcGetPathReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoTrackerServer).HtlcGetPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tkrpc.InfoTracker/HtlcGetPath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoTrackerServer).HtlcGetPath(ctx, req.(*HtlcGetPathReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoTracker_GetHtlcInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHtlcInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoTrackerServer).GetHtlcInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tkrpc.InfoTracker/GetHtlcInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoTrackerServer).GetHtlcInfo(ctx, req.(*GetHtlcInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

// InfoTracker_ServiceDesc is the grpc.ServiceDesc for InfoTracker service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InfoTracker_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tkrpc.InfoTracker",
	HandlerType: (*InfoTrackerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateNodeInfo",
			Handler:    _InfoTracker_UpdateNodeInfo_Handler,
		},
		{
			MethodName: "UpdateUserInfo",
			Handler:    _InfoTracker_UpdateUserInfo_Handler,
		},
		{
			MethodName: "UpdateUserInfos",
			Handler:    _InfoTracker_UpdateUserInfos_Handler,
		},
		{
			MethodName: "GetUserInfo",
			Handler:    _InfoTracker_GetUserInfo_Handler,
		},
		{
			MethodName: "GetUserInfos",
			Handler:    _InfoTracker_GetUserInfos_Handler,
		},
		{
			MethodName: "GetNodes",
			Handler:    _InfoTracker_GetNodes_Handler,
		},
		{
			MethodName: "UpdateChannelInfo",
			Handler:    _InfoTracker_UpdateChannelInfo_Handler,
		},
		{
			MethodName: "UpdateChannelInfos",
			Handler:    _InfoTracker_UpdateChannelInfos_Handler,
		},
		{
			MethodName: "GetChannelInfo",
			Handler:    _InfoTracker_GetChannelInfo_Handler,
		},
		{
			MethodName: "GetChannels",
			Handler:    _InfoTracker_GetChannels_Handler,
		},
		{
			MethodName: "UpdateHtlcInfo",
			Handler:    _InfoTracker_UpdateHtlcInfo_Handler,
		},
		{
			MethodName: "HtlcGetPath",
			Handler:    _InfoTracker_HtlcGetPath_Handler,
		},
		{
			MethodName: "GetHtlcInfo",
			Handler:    _InfoTracker_GetHtlcInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "HeartBeat",
			Handler:       _InfoTracker_HeartBeat_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "info-tracker.proto",
}
