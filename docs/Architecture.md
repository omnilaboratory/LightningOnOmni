## Non Custodial OmniBOLT Daemon

(latest updated Nov 06, 2020)

<p align="center">
  <img width="750" alt="None Custodial OmniBOLT Daemon" src="assets/None-Custodial-OmniBOLT-Daemon-2.png">
</p>

OBD(OmniBOLT daemon) offers two mode: non-custodial mode and exclusive mode. 

## Non-custodial mode
non-custodial mode means clients' seeds and keys are not generated by or stored in obd, but in their own local storage, which is managed by client SDK. Every time a client(wallet) needs to sign a transaction, it receives the transaction's hex from the remote obd it connects, uses corresponding private keys to sign, and sends the signed hex back. The keys will never be exposed to the network. OBD, together with omnicore, validates the signature but has no knowledge of clients' private information. So that even if the obd server has been hacked, users' transaction data are still secure: hackers can not make any transaction to steal without users' seed or key.

Users don't need to trust any obd node, even those nodes they deploy by themselves.


## Exclusive mode
The exclusive mode works in the same way as lnd. Every user MUST run his own obd node， which manages and stores all his keys. For application integrators, obd exposes GRPC API to interact with and the tech stack is the same as lnd.  

Run obd in exclusive mode:
```
$ go run obdserver.go
```

* Invoke [Login](https://api.omnilab.online/?shell#login) gRPC API.
* connect remote peer using [ConnectPeer](https://api.omnilab.online/?shell#connectpeer).
* [OpenChannel](https://api.omnilab.online/?shell#openchannel), fundChannel, and make payment, etc.

For more details of how to use these APIs, please refer to the online documentation at [API Website](https://api.omnilab.online/?shell#obd-grpc-api-reference).


OBD is designed for both (inbound ) liquidity providers and individual users:

## Tracker network

### Rationali  
There are two major purposes for designing a tracker network that separates the full BTC/OMNI node services from obd:  

One is to lower the barrier of deploying and using obd, without waiting days to sync full node data. Another purpose is to make the obd node more adaptable to realistic user scenarios. The user's network is usually unstable and cannot be constantly online. Therefore, trackers play an important role in maintaining network topology, path-finding, message relay, reconnection, etc.

For example, for quickly finding a payment path, each tracker greedily seeks the whole obd network, to build the network topology, which avoids slow fully distributed path-finding algorithms. When an obd queries a path to any tracker for payment, the tracker will be able to respond in milliseconds.  


### Features of the current tracker release
<p align="center">
  <img width="750" alt="how tracker works" src="assets/tracker.png">
</p>

Trackers form a DHT network, and each of them offers the following services for obd nodes:  

1. Full BTC/OMNI node services: create, mint, burn, destroy assets.  

2. Find payment path for peers.  

3. Some statistic works, reporting channel/nodes status, and network status.    

4. Monitor transactions and execute punishment for cheating.    

5. Queue messages for offline nodes. In the case of an obd node going offline, the tracker it is connected maintains a queue to collect incoming messages. (to do)

6. Relay messages when obd is behind a LAN firewall. The messages can be encrypted if a user chooses to(to do).  

When a tracker joins the network, it synchronizes the information of the all obd nodes from the existing tracker network, and then establishes connections with obds to inquire about the status. Obd has the right to reject the inquiries of trackers that are unknown to it(via the white list in configure file).  

### How to use

* [minimum system requirement for a tracker](https://omnilaboratory.github.io/obd/#/OBD-README?id=installation-and-minimum-system-requirement).  

* [tracker installation](https://github.com/omnilaboratory/obd/tree/master/tracker#omnibolt-tracker--in-golang).  

* [tracker configuration](https://github.com/omnilaboratory/obd/tree/master/tracker/config/conf.ini)  

* [connect a tracker when you run your obd](https://omnilaboratory.github.io/obd/#/OBD-README?id=step-2-connect-to-a-tracker).  





### Users MUST know:
1. Only the public channels will seek payment paths from their trackers. And tracker is only able to collect public channel information.   

2. Private channel is invisible to the network, only the owner has the state information.   

3. OBD has an option to encrypt messages when using a tracker as a message relayer, in which case, before the two parties formally send the information, they need to exchange a private key for encryption. The process is the same as the HTTPS protocol.  

4. DO NOT use the tracker recommended by your counterparty.  

5. Broadcast your transactions to your own tracker, a well-known lnd watch tower(or obd tracker), or a safe BTC mining pool to avoid malicious delays in broadcasting your transactions, hence losing the protection of the time-out mechanism of the lightning network. 


## Path Finding Strategies

Currently applied path-finding algorithm on the obd network is the greedy best-first search algorithm. The well-known Dijkstra algorithm( its variation A-star algorithm) is already implemented as one of the path-finding solutions in some of the Lightning implementations. OBD does not set any restrictions on the search algorithm, and each node should choose or implement a search algorithm that is beneficial to itself. 

## liquidity provider

The business model for liquidity providers is straightforward. They connect to as many clients as possible and earn channel fees by providing funded channels as relays of payments. Liquidity providers shall make sure the service quality of their nodes, especially the quality of being constantly online in order to earn more money during their service. With this motivation, we can expect that these liquidity providers bring sufficient funded channels hence better connectivity to the network.

More importantly, when you(the wallet client) go offline, these kinds of nodes keep monitoring your counterparty's activities and punishing cheating activities if there are any, which are basic functions of a lightning node.

We recommend users connect to liquidity providers' nodes and regularly backup channel data to local devices.

## individual user

If you have complete knowledge of how blockchain and lightning network works, you will try to run your own obd node. The new release of obd is easy to install, you should be able to run your own node within 5 minutes. Please go to [installation](https://omnilaboratory.github.io/obd/#/OBD-README?id=installation) to get started.


## LND integration

OBD releases two versions of SDK, one is [js SDK](https://omnilaboratory.github.io/obd/#/js-sdk), the other is integrated with current LND SDK.

<p align="center">
  <img width="750" alt="LND integration" src="assets/LND-integration-2.png">
</p>

Since the LND wallet is a custodial wallet, it stores your seeds and keys in its local storage, then you MUST run your own lnd full node to initiate a wallet.  

OBD provides the same development environment and dependencies as LND. The developer only needs to specify the asset number in the relevant GRPC interfaces, and OBD will automatically process it. For example, when the asset number is equal to 0, the transaction of the BTC channel is processed, and when the asset number is greater than 0, the transaction of the Omni asset channel is processed.  


<!-- 
1. Release an installation package including both lnd and obd, and the two nodes share one omnicore/btccore;   

2. For existing LND nodes, user shall install obd as a plugin, OR: ;  

3. Simply connect to a remote obd node using newly added obd api, which is: ;  

4. Asset related functions that are added to the current LND grpc api set, so that application developers will still work with the original LND interface. If he wants to use asset related functions, he just call the addtional client functions we add.  

5. The original LND APIs are and will be BTC transaction only. Our newly added functions will automatically switch the context to obd node that connected;  

6. New functions have clear context when program an application, and are better than embedding metadata to existing LND api;  -->

<!-- 
1. OBD SDK consists of a websocket client that operates OBD node, and a gRPC server that provide services to applications;  

2. OBD gRPC server calls LND wallet kit to generate seed for a new user, and all keys of this user are derived from this seed;  

3. OBD websocket client connects remote/local OBD node;  

4. Merge OBD gRPC interfaces into LND gRPC api set. Newly added gRPC APIs have distinguishable but indicative names. For example: openAssetChannel, comparing to LND's openChannel which is the BTC only method;  

5. You (application developer) will still work with LND gPRC server, hence no extraneous dependency is brought into your tech stack. When you call asset related functions, OBD gRPC server will automatically switch the context to obd node that is connected;  -->

BTC channel network is logically separated from the asset network. This solution is not finalized yet. If you disagree and believe there are other better ways to let the two networks work together, then I’d love to hear your thinking as well.


The project address is: https://github.com/omnilaboratory/lnd

## OBD Project organization 

* `bean`:  
	* `chainhash`:   
	* `enum`:    

* `config`:  

* `dao`:   

* `lightclient`:  
	 
* `rpc`:  

* `service`:  

* `omnicore`:  

* `tool`:  

* `tracker`:  
	* `bean`:   
	* `dao`:    
	* `service`:   

 
